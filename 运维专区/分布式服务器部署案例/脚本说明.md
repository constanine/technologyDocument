## 应用脚本逻辑说明

### 应用启动脚本

#### 启动模板,`yigo-all-server-start.sh.txt`,复制后的启动脚本
```shell
#!/bin/bash
#server port
#配置服务启动后访问的端口
export YIGO_SERVER_PORT=8089

#DB config
#数据库配置
export DB_SERVER=localhost:3306
export DB_NAME=yigo2erp
export DB_USER=root
export DB_PASS=******
export DB_TYPE=MySQL

#cache config-redis Config
#如果使用redis做共享缓存,redis配置参数
export YIGO_CACHE_MODEL=redis
export REDIS_SERVER_HOST=127.0.0.1
export REDIS_SERVER_PORT=6379
#export REDIS_SERVER_PASSWD=

#license
#yigo的license字符串内容,请不要有断行！
export LICENSE_CONTENT=

#调用yigo应用启动核心启动脚本
./yigo-all-server-start-core.sh $1
```

#### 启动核心脚本,`yigo-all-server-start-core.sh`
```shell
#!/bin/bash
#路径到app-server下
cd ./app-server
#默认应用服务JVM大小为4G
export SERVER_JVM_SIZE=4096;
#如果环境变量YIGO_JVM_SIZE,有设置则应用服务JVM使用该环境变量的设置
if [ $YIGO_JVM_SIZE ]; then
    export SERVER_JVM_SIZE=$YIGO_JVM_SIZE;
fi
#杀掉服务旧进程
ps -ef | grep java | grep "yigo-all-starter-*.jar" | grep -v grep | cut -c 9-15|xargs kill -9;
#准备日期戳(年月日时分秒)
TIMESTAMP=$(date +%Y%m%d.%H%M%S)
#将日志重名为yigo-all-server-end-at-日期戳(年月日时分秒)
mv logs/yigo-all-server.log logs/yigo-all-server-end-at-${TIMESTAMP}.log
#使用nohup命令,守护模式启动应用
nohup java -Xms512m -Xmx${SERVER_JVM_SIZE}m -server -jar ./yigo-all-starter-1.0.0.jar > logs/yigo-all-server.log &
#使用tail -f 命令挂起模式查看日志
tail -f logs/yigo-all-server.log
```

### 更新脚本

#### 一键更新脚本,`yigoupdate.sh`
```shell
#!/bin/bash
#应用启动地址
export DIR_YIGO_SERVER="~/release-publish/yigo-all-server"
#SVN更新操作日志存放地址
export ALIVELOGFOLDER="/data/devops/logs/svn-up-yigo-all-server"
#准备日期时间戳(年月日)
DATESTAMP=$(date +%Y%m%d)
#创建SVN更新操作日志存放地址,包含日期时间戳(年月日)
mkdir -pv "${ALIVELOGFOLDER}/${DATESTAMP}"
#准备SVN更新操作日志具体文件,包含日期时间戳(年月日)
SERVER_ALIVE_LOG="${ALIVELOGFOLDER}/${DATESTAMP}/svn-up.log"

#路径移动到应用启动地址
cd $DIR_YIGO_SERVER
#获取当前SVN本地版本
LOCAL_CURRENTER_VISION=`svn info |grep Revision: |awk '{print $2}'`
#获取当前SVN-REPO版本(最新版本)
SVN_CURRENTER_EVISION=`svn info|grep "Last Changed Rev:"|awk '{print $4}'`
#比较SVN版本是否为最新
if [[ "$LOCAL_CURRENTER_VISION" != "$SVN_CURRENTER_EVISION" ]];then
    #如果SVN版本不是最新
	#先停掉原来运行的服务
    ps -ef | grep java | grep "yigo-all-starter-*.jar" | grep -v grep | cut -c 9-15|xargs kill -9;
	#标记当前正在SVN更新
    export SVN_UPDATEING=1
	#svn更新
    svn up;
	#记录SVN更新日志
    touch ${SERVER_ALIVE_LOG}
    echo "svn up to version $SVN_CURRENTER_EVISION at time `date`" > ${SERVER_ALIVE_LOG}
	#撤销当前正在SVN更新标记
	export SVN_UPDATEING=
	#重启Yigo服务
    ./yigo-all-start.sh
else
    #如果SVN版本是最新,显示显示当前SVN版本已是最新,无需更新
    echo "svn version $SVN_CURRENTER_EVISION is newset! No thing to update"
fi
```

### 运维脚本

#### 应用监听脚本,`yigo-all-server-keepalive-listen.sh`
```shell
#!/bin/bash
#应用启动地址
export DIR_ERP_SERVER="~/release-publish/yigo-all-server"
#监听操作日志存放地址
export ALIVELOGFOLDER="/data/devops/logs/yigo-all-server"
#准备时间戳(年月日)
DATESTAMP=$(date +%Y%m%d)
#创建监听操作日志存放地址,包含当前日期的时间戳(年月日)
mkdir -pv "${ALIVELOGFOLDER}/${DATESTAMP}"
#准备监听日志的文件名
SERVER_ALIVE_LOG="${ALIVELOGFOLDER}/${DATESTAMP}/yigo-all-server-alive.log"
#准备记录监听内容到日志
touch "${SERVER_ALIVE_LOG}"
#判断当前有SVN更新标记
if [ $SVN_UPDATEING && $SVN_UPDATEING -gt 0 ];
then
    #如果当前有SVN更新标记,则记录当前在svn更新,不重启,也不判断应用是否运行,默认当前应用是停止的
    echo "Now is svn updating,skip alive checking!" >> ${SERVER_ALIVE_LOG}
else
    #如果当前没有SVN更新标记,则查看当前应用是否运行
    ps -ef | grep java | grep "yigo-all-starter-.*.jar"
    if [ $?  -ne 0 ];
    then
        #如果发现服务没有运行了,就记入到WARNNING日志中
        echo "[WARNNING] at Time:`date` found yigo-all-server is stoped!" >> ${SERVER_ALIVE_LOG}
        echo "[WARNNING] Why yigo-all-server is stoped? Reason from log:>" >> ${SERVER_ALIVE_LOG}
        #抽取日志末尾200行,到监听日志,辅助判断是何问题所致
        tail -n 200 ${DIR_ERP_SERVER}/logs/yigo-all-server.log >> ${SERVER_ALIVE_LOG}
        #尝试重启服务
        echo "[WARNNING] now restarting service... " >> ${SERVER_ALIVE_LOG}
        cd ${DIR_ERP_SERVER}
        ./yigo-all-server-start.sh
    else
        #如果服务正常运行,则简单记录当前时间服务仍在运行
        echo "[INFO] `date` yigo-all-server is alive! " >> ${SERVER_ALIVE_LOG}
    fi
fi
```

#### 数据库备份脚本,`mysql-backup.sh`
```shell
#! /bin/bash

#加载当前用户的环境变量
. $HOME/.profile
echo $HOME
# shell options
set -o nounset
set -o errexit
set -x

#获取时间戳-年月日时分秒
TIMESTAMP=$(date +%Y%m%d.%H%M%S)
#获取时间戳-年月日
DATESTAMP=$(date +%Y%m%d)
#获取缓存池标号,一般按月来算就是1-31
POOL_NUM=$(date +%d%p)
#数据备份操作日志的存放地址
LOG_FOLDER="/data/devops/backup/logs"
#创建数据备份操作日志的存放地址
mkdir -pv ${LOG_FOLDER}
#数据备份操作日志的具体文件名,以时间戳-年月日时分秒为区分
LOG_FILE="$LOG_FOLDER/mysqldatabackup-$TIMESTAMP.log"
#日志内容
echo "Run [$*] at $TIMESTAMP , with log file $LOG_FILE ..."
echo -e "\n" >> "$LOG_FILE"
echo "********************************************************************************" >> "$LOG_FILE"
echo "*                                                                              *" >> "$LOG_FILE"
echo "*  Begin to run [mysqldump] ..."                                                  >> "$LOG_FILE"
echo "*   - User    : `whoami`"                                                         >> "$LOG_FILE"
echo "*   - Time    : `date`"                                                           >> "$LOG_FILE"
echo "*   - Log file: $LOG_FILE"                                                        >> "$LOG_FILE"
echo "*                                                                              *" >> "$LOG_FILE"
echo "********************************************************************************" >> "$LOG_FILE"
echo -e "\n" >> "$LOG_FILE"

#根据环境变量ARCHIVE_DATE,判断是否为归档备份,默认15号为归档日期
TO_ARCHIVE=0
if [[ "${ARCHIVE_DATE}" = "$(date +%d)" || "15" = "$(date +%d)" ]];then
    TO_ARCHIVE=1
fi

#mysqldump的数据库连接参数配置,所以请配置好以下环境变量
#MYSQL_USERNAME    数据库服务用户名
#MYSQL_PASSWORD    数据库服务用户密码
#MYSQL_SERVER_HOST 数据库服务ip
#MYSQL_SERVER_PORT 数据库服务端口
MYSQL_ARGS="--add-drop-table -u${MYSQL_USERNAME} -p${MYSQL_PASSWORD} --host=${MYSQL_SERVER_HOST} --port=${MYSQL_SERVER_PORT}"

#数据备份存放地址
BACKUP_DIR=/data/devops/backup
#数据备份存放地址-日期池
DAILY_BACKUP_DIR="${BACKUP_DIR}/daily"
#创建数据备份存放地址-日期池
mkdir -pv ${DAILY_BACKUP_DIR}

#数据库备份函数,参数,备份数据库名称
doBackup() {
    #默认当前备份的文件放入数据备份存放地址-日期池,以当前日期作为标号,轮询覆盖替换
    BACKUP_FILE="${DAILY_BACKUP_DIR}/$1-${POOL_NUM}.sql"
    #执行备份
    mysqldump ${MYSQL_ARGS} $1 > "${BACKUP_FILE}"
    #去掉就的压缩备份
    rm -fv "${BACKUP_FILE}.gz"
    #压缩新的备份文件
    gzip -v "${BACKUP_FILE}"

    #如果是归档行备份,复制到归档存放地址
    if [[ "1" = "${TO_ARCHIVE}" ]];then
        #准备归档存放地址
        ARCH_BACKUP_DIR="${BACKUP_DIR}/archive/${TIMESTAMP}"
        #创建归档存放地址
        mkdir -pv ${ARCH_BACKUP_DIR}
        #将当前压缩备份,复制到归档存放地址下
        cp -v "${BACKUP_FILE}.gz" "${ARCH_BACKUP_DIR}"
    fi
}

#备份 yigo2erp库
doBackup yigo2erp


set +x
#继续备份操作日志记录备份结果
echo -e "\n" >> "$LOG_FILE"
echo "********************************************************************************" >> "$LOG_FILE"
echo "*                                                                              *" >> "$LOG_FILE"
echo "*  Run [mysql-backup] completed, `date`."                                        >> "$LOG_FILE"
echo "*                                                                              *" >> "$LOG_FILE"
echo "********************************************************************************" >> "$LOG_FILE"
echo -e "\n\n\n" >> "$LOG_FILE"
```

#### 附件备份脚本,`attachment-file-backup.sh`
```shell
#!/bin/bash
#服务app原本启动地址
export DIR_ERP_SERVER="~/release-publish/yigo-all-server"
#附件备份地址
export BACKUP_FLODER="/data/devops/backup/attachment/yigo-all-server"
#该次本分操作日志存放地址
export LOGFOLDER="/data/devops/logs/yigo-all-server-attach-backup"
#如果附件备份地址不存在,则新建
mkdir -pv "${BACKUP_FLODER}"
#如果操作日志存放地址不存在,则新建
mkdir -pv "${LOGFOLDER}"
#以当前日期为时间戳-年月日
DATESTAMP=$(date +%Y%m%d)
#具体操作日志文件名
BACKUP_FILE_LIST_LOG=${LOGFOLDER}/${DATESTAMP}.log
touch ${BACKUP_FILE_LIST_LOG}
#删除旧备份
rm -f ${BACKUP_FLODER}/attachment-backup.tar.gz
#压缩附件,制作新的备份
tar -czvf ${DIR_ERP_SERVER}/Data 
#备份成功输出操作日志
echo "backup attachment file completed!" > ${BACKUP_FILE_LIST_LOG}
echo "backup file list:"
ll ${DIR_ERP_SERVER}/Data >> ${BACKUP_FILE_LIST_LOG}
```

### 其他脚本
#### redis辅助启动脚本,`redis-server-controll.sh`
```shell

```
